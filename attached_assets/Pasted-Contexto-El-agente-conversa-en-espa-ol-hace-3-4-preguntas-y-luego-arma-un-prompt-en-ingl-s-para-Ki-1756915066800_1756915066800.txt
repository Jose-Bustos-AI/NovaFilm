Contexto

El agente conversa en espaÃ±ol, hace 3â€“4 preguntas y luego arma un prompt en inglÃ©s para Kie.

A veces, tras una respuesta libre del usuario (â€œsÃ­, hojas caÃ­das, tormenta y vientoâ€¦â€), el chat muestra â€œError en la respuestaâ€.

Esto casi seguro es por fallos de parseo/validaciÃ³n del mensaje del modelo (JSON parcial, campos faltantes, formato inesperado, tildes/typos, etc.) o por estados de conversaciÃ³n que no toleran entradas libres.

ğŸ›‘ Regla de oro (no romper lo que ya funciona)

No tocar nada del flujo de generaciÃ³n, jobs, callbacks, seeds, DB ni del modelo ya configurado.
Solo endurecer el agente y su parser para que:

Nunca muestre â€œError en la respuestaâ€ al usuario.

Siempre degrade con gracia: repite o reformula la pregunta, o usa valores por defecto.

Siga preguntando y cierre el prompt final sin bloquearse.

âœ… Instrucciones (pasos claros)

Manejar errores con gracia en /api/chat

En el backend del chat, captura cualquier excepciÃ³n de la llamada al modelo o del parser y no devuelvas â€œError en la respuestaâ€.

En su lugar, responde al usuario (en espaÃ±ol):

â€œNo me quedÃ³ claro, Â¿puedes decirlo en una frase mÃ¡s corta?â€

Ofrece opciones rÃ¡pidas (botones/chips) cuando aplique.

Parser tolerante a JSON y texto libre

Antes de parsear JSON, intenta extraer bloque JSON con heurÃ­stica (buscar el primer { y el Ãºltimo } y validar).

Si no hay JSON vÃ¡lido, interpreta texto libre y asigna rasgos detectados (dÃ­a/noche, clima, tipo de vehÃ­culo, presencia de gente, etc.).

Acepta sinÃ³nimos y typos comunes en espaÃ±ol (sÃ­/si, noche/nocturno, lluvia/lloviendo, viento/ventoso, hojas/hojas caÃ­dasâ€¦).

Campos faltantes â‡’ valores por defecto:

duraciÃ³n = 8s (no preguntar)

relaciÃ³n de aspecto = 9:16 (no preguntar)

idioma del prompt final = inglÃ©s (siempre)

Normaliza respuestas a categorÃ­as cerradas (ej.: clima:{soleado, nublado, lluvia, tormenta}, momento:{dÃ­a, atardecer, noche}, gente:{sÃ­, no}, tipo_moto:{competiciÃ³n, cross, custom/harley}, tono:{cinemÃ¡tico, emocionante, documental}).

Estado conversacional robusto

MantÃ©n un pequeÃ±o state machine por sesiÃ³n (en memoria o sesiÃ³n) con los slots:

tema/escena, momento del dÃ­a, clima, tipo de vehÃ­culo/estilo, presencia de gente, tono.

Cada turno:

Si un slot estÃ¡ vacÃ­o, pregunta solo ese slot con 2â€“4 opciones breves y permite respuesta libre.

Si una respuesta es ambigua/no parseable, repregunta con opciones y ejemplo (â€œPor ejemplo: dÃ­a / atardecer / nocheâ€).

Cuando estÃ©n cubiertos los slots, arma el prompt final en inglÃ©s y dispara la creaciÃ³n del vÃ­deo (sin bloquear la UI).

Mensajes al usuario siempre en espaÃ±ol y claros

Sustituye el mensaje genÃ©rico por:

â€œCreo que me faltÃ³ un detalle. Â¿Te refieres a dÃ­a, atardecer o noche?â€

â€œÂ¿El clima deberÃ­a ser seco, lluvia o tormenta?â€

Tras reunir todo:

â€œPerfecto, ya tengo todo. Estoy preparando tu vÃ­deo. Suele tardar 2â€“5 minutos. Te aviso en cuanto estÃ© listo.â€

Logs y diagnÃ³stico (solo servidor)

AÃ±ade logs estructurados en /api/chat: stage, userId, turn, slots_filled, raw_model_reply, parse_ok.

Cuando haya recuperaciÃ³n (fallback), loguea fallback_used:true y quÃ© estrategia se aplicÃ³ (regex, defaults, repregunta).

No tocar lo que funciona

MantÃ©n: creaciÃ³n de jobs, validaciones actuales, seeds por defecto, modelo conversacional ya elegido, y los textos de ETA en espaÃ±ol.

El prompt final en inglÃ©s debe conservar calidad cinematogrÃ¡fica y estructura que ya tenÃ­amos.

UX de repregunta (frontend)

Si el backend devuelve needs_clarification:true y choices:["dÃ­a","atardecer","noche"], muestra chips clicables ademÃ¡s de permitir texto.

Reemplaza el texto â€œError en la respuestaâ€ por el mensaje de repregunta del backend.

Pruebas rÃ¡pidas

Caso 1 (texto libre): â€œsÃ­ hojas caÃ­das hay tormenta y viento y llueve muchoâ€ â‡’ Debe mapear a clima: tormenta/lluvia, elementos: hojas, viento: sÃ­, y pasar.

Caso 2 (typos): â€œllueve muchho, de nocheâ€ â‡’ debe tolerar y normalizar a lluvia, noche.

Caso 3 (respuesta vacÃ­a) â‡’ repregunta con opciones.

Caso 4 (modelo responde sin JSON) â‡’ extracciÃ³n por texto y seguir.
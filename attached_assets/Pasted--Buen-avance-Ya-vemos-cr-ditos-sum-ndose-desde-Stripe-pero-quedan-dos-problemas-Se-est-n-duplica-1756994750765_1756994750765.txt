Â¡Buen avance!
Ya vemos crÃ©ditos sumÃ¡ndose desde Stripe, pero quedan dos problemas:

Se estÃ¡n duplicando (te dio +10 al comprar Basic)

En â€œMi Cuentaâ€ aÃºn sale â€œSin suscripciÃ³n activaâ€

ğŸ§  Contexto

En Stripe vemos eventos: checkout.session.completed, invoice.payment_succeeded y tambiÃ©n invoice.paid.

En DB ya guardas stripe_events.

Los crÃ©ditos se aÃ±aden, pero parece que estÃ¡s contando dos veces la misma factura (ej. contando invoice.payment_succeeded y invoice.paid para el mismo invoice).

El campo users.active_plan no se estÃ¡ actualizando tras un pago exitoso, por eso la UI muestra â€œSin suscripciÃ³n activaâ€.

ğŸ›¡ï¸ Regla de oro (muy importante)

No toques login, consumo de crÃ©ditos por vÃ­deo ni el resto de la app.

Cambios solo en billing/Stripe (webhook + backfill + UI del plan).

Idempotencia estricta: una factura de Stripe nunca puede sumar crÃ©ditos mÃ¡s de una vez.

Ante dudas/duplicados, responder 200 a Stripe pero no sumar crÃ©ditos.

âœ… Instrucciones para Replit (haz exactamente esto)
1) Filtra eventos: solo sumar crÃ©ditos con invoice.payment_succeeded

No sumes crÃ©ditos en invoice.paid.

checkout.session.completed solo sirve para vincular el stripe_customer_id y redirigir; no suma crÃ©ditos.

En el webhook de Stripe (Dashboard), deja activos solo:

checkout.session.completed

invoice.payment_succeeded

(opcional) customer.subscription.deleted para desactivar plan

Si invoice.paid sigue llegando, ignÃ³ralo en el cÃ³digo (log y 200 OK).

2) Idempotencia por invoice.id (no por event.id)

Muchas veces Stripe envÃ­a varios eventos para la misma factura.

Antes de sumar, comprueba si ese invoice.id ya fue aplicado.

Implementa una protecciÃ³n fuerte:

Crea un registro/tabla processed_invoices (PK: invoice_id) o aÃ±ade un unique index en credits_ledger(meta->>'invoice_id').

Si ya existe ese invoice_id, log billing> SKIPPED duplicate invoice=<id> y no sumes.

Todo en una transacciÃ³n: registrar processed_invoices, sumar crÃ©ditos, setear plan y credits_renew_at, insertar en credits_ledger, guardar stripe_events.

3) Activar y mostrar plan activo

En invoice.payment_succeeded, ademÃ¡s de sumar crÃ©ditos:

Determina el priceId (con expand si hace falta).

Normaliza a basic | pro | max comparando con STRIPE_PRICE_BASIC/PRO/MAX.

Actualiza:

users.active_plan = basic|pro|max

users.credits_renew_at = current_period_end (de invoice.lines.data[0].period.end o subscription.current_period_end)

En la UI de â€œMi Cuentaâ€:

Si users.active_plan != null â†’ mostrar â€œPlan activo: Basic/Pro/Maxâ€ y â€œRenueva el: â€¦â€

Si es null â†’ â€œSin suscripciÃ³n activaâ€.

4) Limpieza y backfill (arreglar lo ya duplicado)

Crea una tarea/endpoint one-off para:

Detectar duplicados del mismo invoice_id en credits_ledger (o en tu nueva tabla de idempotencia).

Dejar solo uno; el resto revertirlos (insertar un movimiento de correcciÃ³n -X en credits_ledger o recalcular saldo).

Recalcular users.credits como SUM(credits_ledger.amount) para ese usuario.

Crea un backfill: re-procesa Ãºnicamente eventos invoice.payment_succeeded no presentes en processed_invoices (o sin invoice_id aplicado), usando la misma lÃ³gica, para dejar todo consistente.

5) Reglas de negocio extra (evitar falsos positivos)

Solo sumar cuando invoice.billing_reason âˆˆ {subscription_create, subscription_cycle} y amount_paid > 0.

Ignorar prorrateos/facturas cero (si lines.data[*].proration = true o amount_paid = 0).

En upgrades/downgrades, el siguiente payment_succeeded actualizarÃ¡ el plan y aÃ±adirÃ¡ los crÃ©ditos del nuevo plan.

6) Logs de diagnÃ³stico (prefijo billing>)

billing> WEBHOOK: type=<type> evt=<id>

billing> INVOICE: id=<invoice.id> amount_paid=<amount> reason=<billing_reason>

billing> priceId=<priceId> plan=<plan>

billing> APPLIED: +<credits> plan=<plan> renewAt=<ISO> user=<id> invoice=<id>

billing> SKIPPED duplicate invoice=<id>

7) Pruebas de verificaciÃ³n (QA)

Enviar evento de prueba invoice.payment_succeeded desde Stripe:

Debe crear un apunte en credits_ledger con invoice_id, no duplicarse.

Debe actualizar active_plan y credits_renew_at.

Hacer un checkout real de Basic:

Debe sumar +5 solo una vez.

â€œMi Cuentaâ€ debe mostrar â€œPlan activo: Basicâ€ y â€œRenueva el: â€¦â€.

Reintentar el webhook del mismo invoice:

Debe salir SKIPPED duplicate invoice=... y no alterar crÃ©ditos.

ğŸ§¾ Resumen corto para que lo arreglen rÃ¡pido

âœ… Solo sumar en invoice.payment_succeeded. Ignorar invoice.paid.

âœ… Idempotencia por invoice.id (unique) â€” nunca por event.id.

âœ… En ese mismo punto, setear active_plan y credits_renew_at.

âœ… UI: mostrar plan activo si users.active_plan tiene valor.

âœ… Backfill y limpieza: revertir duplicados existentes y dejar crÃ©ditos coherentes.

Con esto se corrigen ambos problemas: (1) no mÃ¡s duplicados y (2) el plan aparece activo tras el pago.